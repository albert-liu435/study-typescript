// 泛型
// 泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用，常用于：函数，接口，class中。

// 需求：创建一个id函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）。

// 解释：

// 语法：在函数名称的后面添加< > <><>(尖括号)，尖括号中添加类型变量，比如此处的Type。
// 类型变量Type，是一种特殊类型的变量，只用于表示类型而不是值。
// Type类型变量相当于一个类型容器，能够捕获用户传入的类型（比如：number）（具体是什么类型由用户>调用该函数时指定）。
// 因为Type是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型。
// 类型变量Type，可以是任意合法的变量名称。
// ————————————————
// 版权声明：本文为CSDN博主「蜡笔雏田学前端」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
// 原文链接：https://blog.csdn.net/xuxuii/article/details/126724000

function id<Type>(value: Type): Type {
  return value;
}

// //解释：

// 语法：在函数名称后面添加< > <><>(尖括号)，尖括号中指定具体的类型，比如，此处的number。
// 当传入类型number后，这个类型就会被函数声明时指定的类型变量Type捕捉到。
// 此时，Type的类型就是number，所以，函数id参数和返回值类型也都是number。
// ————————————————
// 版权声明：本文为CSDN博主「蜡笔雏田学前端」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
// 原文链接：https://blog.csdn.net/xuxuii/article/details/126724000
//调用泛型函数：
// 1 以number类型调用泛型函数
const num = id<number>(10);

// 2 以string类型调用泛型函数
const str = id<string>("a");

// 3 以boolean类型调用泛型函数
const ret = id<boolean>(true);

// 同样，如果传入类型string，函数id参数和返回值的类型就都是string。

// 这样，通过泛型就做到了让id函数与多种不同的类型一起工作，实现了复用的同时保证了类型的安全。

// 简化调用泛型函数

// 解释：

// 在调用泛型函数时，可以省略<类型>来简化泛型函数的调用。
// 此时，TS内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量Type的类型。
// 比如，传入实参10，TS会自动推断出变量num的类型number，并作为Type的类型。

let num1 = id(100);
let str1 = id("abc");



